name: 'Download Artifact with SHA256 Verification'
description: 'Download artifacts with automatic retry and cryptographic integrity verification'
author: 'WAMP Protocol'

inputs:
  name:
    description: 'Artifact name to download'
    required: true
  path:
    description: 'Destination path for downloaded files'
    required: false
    default: './'
  run-id:
    description: 'Workflow run ID to download from (default: current run)'
    required: false
  github-token:
    description: 'GitHub token for artifact download'
    required: false
    default: ${{ github.token }}
  max-attempts:
    description: 'Maximum download retry attempts'
    required: false
    default: '3'
  retry-delay:
    description: 'Delay between retries in seconds'
    required: false
    default: '60'
  overwrite:
    description: 'Whether to overwrite existing files during extraction (default: false for safety)'
    required: false
    default: 'false'

outputs:
  success:
    description: 'true if download and verification succeeded'
    value: ${{ steps.verify.outputs.success }}
  file-count:
    description: 'Number of files verified'
    value: ${{ steps.verify.outputs.file-count }}
  meta-checksum:
    description: 'Meta-checksum of downloaded CHECKSUMS.sha256'
    value: ${{ steps.verify.outputs.meta-checksum }}

runs:
  using: 'composite'
  steps:
    - name: Download and verify artifact with retry logic
      id: verify
      shell: bash
      env:
        ARTIFACT_NAME: ${{ inputs.name }}
        DOWNLOAD_PATH: ${{ inputs.path }}
        RUN_ID: ${{ inputs.run-id }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        MAX_ATTEMPTS: ${{ inputs.max-attempts }}
        RETRY_DELAY: ${{ inputs.retry-delay }}
        OVERWRITE: ${{ inputs.overwrite }}
      run: |
        set -euo pipefail

        echo "======================================================================"
        echo "==> Downloading Artifact with Verification (Chain of Custody)"
        echo "======================================================================"
        echo ""
        echo "Artifact: $ARTIFACT_NAME"
        echo "Destination: $DOWNLOAD_PATH"
        echo "Max attempts: $MAX_ATTEMPTS"
        echo "Retry delay: ${RETRY_DELAY}s"
        echo ""

        # Create a unique staging directory for this download
        # This isolates the download/verify process from the final destination,
        # preventing retry cleanup from wiping files from OTHER successful downloads
        # when multiple artifacts are downloaded to the same destination directory.
        STAGING_DIR=$(mktemp -d)
        echo "Staging directory: $STAGING_DIR"
        echo ""

        # Ensure staging directory is cleaned up on exit (success or failure)
        cleanup_staging() {
          if [ -d "$STAGING_DIR" ]; then
            rm -rf "$STAGING_DIR"
          fi
        }
        trap cleanup_staging EXIT

        # Main retry loop
        for attempt in $(seq 1 $MAX_ATTEMPTS); do
          echo "────────────────────────────────────────────────────────────────────"
          echo "Attempt $attempt of $MAX_ATTEMPTS"
          echo "────────────────────────────────────────────────────────────────────"
          echo ""

          # Clean STAGING directory on retry (NOT the final destination!)
          # This is safe because staging only contains files from THIS download attempt
          if [ $attempt -gt 1 ]; then
            echo "Cleaning staging directory from previous failed attempt..."
            rm -rf "${STAGING_DIR:?}"/*
            echo ""
          fi

          # Download artifact using GitHub API
          echo "Downloading artifact via GitHub API..."

          # Determine the run ID to use
          EFFECTIVE_RUN_ID="${RUN_ID:-$GITHUB_RUN_ID}"
          echo "Using run ID: $EFFECTIVE_RUN_ID"

          # Get artifact by name - supports both exact match and prefix match
          # The upload-artifact-verified action appends a meta-checksum suffix to artifact names
          # (e.g., "my-artifact" becomes "my-artifact-abc123..."), so we need to find artifacts
          # that start with the requested base name.
          echo "Looking up artifact: $ARTIFACT_NAME"

          # First try exact match
          ARTIFACT_JSON=$(gh api \
            "/repos/$GITHUB_REPOSITORY/actions/runs/$EFFECTIVE_RUN_ID/artifacts" \
            --jq ".artifacts[] | select(.name == \"$ARTIFACT_NAME\")" 2>&1 || echo "")

          if [ -z "$ARTIFACT_JSON" ]; then
            # No exact match - try prefix match (for artifacts with meta-checksum suffix)
            echo "No exact match, trying prefix match for: ${ARTIFACT_NAME}-"
            ARTIFACT_JSON=$(gh api \
              "/repos/$GITHUB_REPOSITORY/actions/runs/$EFFECTIVE_RUN_ID/artifacts" \
              --jq ".artifacts[] | select(.name | startswith(\"${ARTIFACT_NAME}-\"))" 2>&1 || echo "")

            if [ -z "$ARTIFACT_JSON" ]; then
              echo "❌ Artifact not found: $ARTIFACT_NAME (tried exact and prefix match)"
              # List available artifacts for debugging
              echo ""
              echo "Available artifacts in run $EFFECTIVE_RUN_ID:"
              gh api "/repos/$GITHUB_REPOSITORY/actions/runs/$EFFECTIVE_RUN_ID/artifacts" \
                --jq '.artifacts[].name' 2>&1 | head -20 || echo "(failed to list)"
              echo ""
              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "⏳ Retrying in ${RETRY_DELAY}s..."
                sleep "$RETRY_DELAY"
                continue
              else
                echo "❌ Max retry attempts reached"
                exit 1
              fi
            fi
          fi

          # Handle case where multiple artifacts match the prefix (shouldn't happen, but be safe)
          MATCH_COUNT=$(echo "$ARTIFACT_JSON" | jq -s 'length')
          if [ "$MATCH_COUNT" -gt 1 ]; then
            echo "⚠️  Multiple artifacts match prefix '$ARTIFACT_NAME-', using most recent"
            # Sort by created_at descending and take the first one
            ARTIFACT_JSON=$(echo "$ARTIFACT_JSON" | jq -s 'sort_by(.created_at) | reverse | .[0]')
          fi

          ARTIFACT_ID=$(echo "$ARTIFACT_JSON" | jq -r '.id')
          ACTUAL_ARTIFACT_NAME=$(echo "$ARTIFACT_JSON" | jq -r '.name')

          if [ -z "$ARTIFACT_ID" ] || [ "$ARTIFACT_ID" = "null" ]; then
            echo "❌ Failed to parse artifact ID"
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached"
              exit 1
            fi
          fi

          echo "Found artifact: $ACTUAL_ARTIFACT_NAME (ID: $ARTIFACT_ID)"

          # Update ARTIFACT_NAME to the actual name for later self-verification
          ARTIFACT_NAME="$ACTUAL_ARTIFACT_NAME"

          # Download the artifact zip to STAGING directory (not final destination yet)
          echo "Downloading artifact zip to staging..."
          if ! gh api "/repos/$GITHUB_REPOSITORY/actions/artifacts/$ARTIFACT_ID/zip" > "$STAGING_DIR/artifact.zip" 2>&1; then
            echo "❌ Download failed"
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached"
              exit 1
            fi
          fi

          # Unzip to STAGING directory (verification happens here before moving to final destination)
          echo "Extracting artifact to staging..."

          # In staging, always use overwrite mode (-o) since we clean staging on retry
          if ! unzip -q -o "$STAGING_DIR/artifact.zip" -d "$STAGING_DIR" 2>&1; then
            echo "❌ Extraction failed"
            rm -f "$STAGING_DIR/artifact.zip"
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached"
              exit 1
            fi
          fi

          # Clean up zip file
          rm -f "$STAGING_DIR/artifact.zip"

          echo "✅ Download completed to staging"
          echo ""

          # Sync filesystem after download
          echo "Syncing filesystem after download..."
          sync
          echo "✅ Filesystem synced"
          echo ""

          # Change to STAGING directory for verification
          cd "$STAGING_DIR"

          # Normalize line endings to Unix format (defense in depth)
          # ZIP extraction or text file auto-conversion could introduce CRLF
          echo "Normalizing checksum file line endings..."
          if [ -f "CHECKSUMS.sha256" ]; then
            tr -d '\r' < CHECKSUMS.sha256 > CHECKSUMS.sha256.tmp
            mv CHECKSUMS.sha256.tmp CHECKSUMS.sha256
            echo "✅ Line endings normalized (CRLF → LF)"
          else
            echo "⚠️  CHECKSUMS.sha256 not found yet, skipping normalization"
          fi
          echo ""

          # Verify checksum files exist
          echo "Checking for verification files..."
          if [ ! -f "CHECKSUMS.sha256" ]; then
            echo "❌ CHECKSUMS.sha256 missing"
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached"
              exit 1
            fi
          fi

          if [ ! -f "CHECKSUMS.sha256.meta" ]; then
            echo "❌ CHECKSUMS.sha256.meta missing"
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached"
              exit 1
            fi
          fi

          echo "✅ Verification files present"
          echo ""

          # Verify meta-checksum
          echo "Verifying checksum file integrity..."
          EXPECTED_META=$(cat CHECKSUMS.sha256.meta | tr -d ' \n')
          ACTUAL_META=$(openssl sha256 CHECKSUMS.sha256 | awk '{print $2}')

          if [ "$ACTUAL_META" != "$EXPECTED_META" ]; then
            echo "❌ CHECKSUMS.sha256 corrupted during transfer!"
            echo "   Expected meta-checksum: $EXPECTED_META"
            echo "   Actual meta-checksum:   $ACTUAL_META"
            echo ""
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s (GitHub storage may not be ready)..."
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached - persistent corruption detected"
              exit 1
            fi
          fi

          echo "✅ Checksum file integrity verified"
          echo "   Meta-checksum: $ACTUAL_META"
          echo ""

          # Self-verification: Extract expected meta-checksum from artifact name
          echo "Verifying artifact name matches content (self-verification)..."
          EXPECTED_META_FROM_NAME=$(echo "$ARTIFACT_NAME" | grep -oE '[a-f0-9]{64}$' || echo "")

          if [ -n "$EXPECTED_META_FROM_NAME" ]; then
            # Artifact name contains meta-checksum suffix - verify it matches content
            if [ "$ACTUAL_META" != "$EXPECTED_META_FROM_NAME" ]; then
              echo "❌ ARTIFACT NAME MISMATCH - GitHub served wrong artifact!"
              echo ""
              echo "This is a critical corruption bug in GitHub Actions infrastructure."
              echo "The artifact name promises different content than what was delivered."
              echo ""
              echo "   Artifact name:           $ARTIFACT_NAME"
              echo "   Expected meta-checksum:  $EXPECTED_META_FROM_NAME"
              echo "   Actual meta-checksum:    $ACTUAL_META"
              echo ""
              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "⏳ Retrying in ${RETRY_DELAY}s (GitHub may have served wrong artifact)..."
                sleep "$RETRY_DELAY"
                continue
              else
                echo "❌ Max retry attempts reached - persistent artifact mismatch"
                echo "   GitHub's artifact storage appears to be corrupted or confused."
                exit 1
              fi
            fi
            echo "✅ Artifact name matches content (meta-checksum verified)"
            echo "   Self-verification confirms artifact identity"
          else
            echo "⚠️  Artifact name does not contain meta-checksum suffix"
            echo "   Skipping self-verification (legacy artifact naming)"
          fi
          echo ""

          # Verify individual files
          echo "Verifying individual file checksums..."
          echo ""

          HAS_ERRORS=0
          FILES_VERIFIED=0
          FILES_FAILED=0
          declare -a VERIFIED_FILES
          declare -a FAILED_FILES

          while IFS= read -r line; do
            # Parse openssl output: "SHA256(./file.whl)= checksum" or "SHA2-256(./file.whl)= checksum"
            EXPECTED_CHECKSUM=$(echo "$line" | awk -F'= ' '{print $2}')
            FILE_PATH=$(echo "$line" | sed 's/SHA\(2-\)\?256(\(.*\))=.*/\2/')

            # Skip checksum files themselves
            if [[ "$FILE_PATH" == *"CHECKSUMS.sha256"* ]]; then
              continue
            fi

            if [ ! -f "$FILE_PATH" ]; then
              echo "❌ Missing: $FILE_PATH"
              FAILED_FILES+=("$FILE_PATH (missing)")
              FILES_FAILED=$((FILES_FAILED + 1))
              HAS_ERRORS=1
              continue
            fi

            ACTUAL_CHECKSUM=$(openssl sha256 "$FILE_PATH" | awk '{print $2}')

            if [ "$ACTUAL_CHECKSUM" = "$EXPECTED_CHECKSUM" ]; then
              echo "✅ $(basename "$FILE_PATH")"
              VERIFIED_FILES+=("$FILE_PATH")
              FILES_VERIFIED=$((FILES_VERIFIED + 1))
            else
              echo "❌ $(basename "$FILE_PATH"): CHECKSUM MISMATCH!"
              echo "   Expected: $EXPECTED_CHECKSUM"
              echo "   Actual:   $ACTUAL_CHECKSUM"
              FAILED_FILES+=("$FILE_PATH (mismatch)")
              FILES_FAILED=$((FILES_FAILED + 1))
              HAS_ERRORS=1
            fi
          done < CHECKSUMS.sha256

          echo ""

          # Summary table
          echo "======================================================================"
          echo "Verification Summary (Attempt $attempt/$MAX_ATTEMPTS)"
          echo "======================================================================"
          echo "Artifact:          $ARTIFACT_NAME"
          echo "Meta-checksum:     $ACTUAL_META"
          echo "Files verified:    $FILES_VERIFIED"
          echo "Files failed:      $FILES_FAILED"
          echo ""

          if [ $HAS_ERRORS -eq 0 ]; then
            echo "┌────────────────────────────────────────────────────────────────┐"
            echo "│ ✅ SUCCESS - All files verified in staging                     │"
            echo "└────────────────────────────────────────────────────────────────┘"
            echo ""

            # Now move verified files from staging to final destination
            echo "Moving verified files to final destination: $DOWNLOAD_PATH"
            mkdir -p "$DOWNLOAD_PATH"

            # Handle overwrite mode for final destination
            # Use -r for recursive copy (artifacts may contain directories)
            if [ "$OVERWRITE" = "true" ]; then
              echo "Overwrite mode: enabled (will replace existing files)"
              # Copy recursively with overwrite (cp -rf)
              cp -rf "$STAGING_DIR"/* "$DOWNLOAD_PATH/" 2>/dev/null || true
            else
              echo "Overwrite mode: disabled (will skip existing files)"
              # Copy recursively without overwrite (cp -rn)
              cp -rn "$STAGING_DIR"/* "$DOWNLOAD_PATH/" 2>/dev/null || true
            fi

            echo "✅ Files moved to final destination"
            echo ""

            # Output for GitHub Actions
            echo "success=true" >> $GITHUB_OUTPUT
            echo "file-count=$FILES_VERIFIED" >> $GITHUB_OUTPUT
            echo "meta-checksum=$ACTUAL_META" >> $GITHUB_OUTPUT

            echo "======================================================================"
            echo ""
            exit 0
          else
            echo "┌────────────────────────────────────────────────────────────────┐"
            echo "│ ❌ FAILED - Checksum verification errors detected              │"
            echo "└────────────────────────────────────────────────────────────────┘"
            echo ""

            if [ ${#FAILED_FILES[@]} -gt 0 ]; then
              echo "Failed files:"
              for file in "${FAILED_FILES[@]}"; do
                echo "  - $file"
              done
              echo ""
            fi

            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "⏳ Retrying in ${RETRY_DELAY}s..."
              echo "======================================================================"
              echo ""
              sleep "$RETRY_DELAY"
              continue
            else
              echo "❌ Max retry attempts reached - giving up"
              echo "======================================================================"
              echo ""

              # Output for GitHub Actions
              echo "success=false" >> $GITHUB_OUTPUT
              echo "file-count=0" >> $GITHUB_OUTPUT

              exit 1
            fi
          fi
        done

branding:
  icon: 'download'
  color: 'blue'
